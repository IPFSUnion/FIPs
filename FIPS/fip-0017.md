---
fip: 0017
title: Lightweight Sector updates
author: @nicola, @lucaniz, @rosariogennaro, @irenegia, @Kubuxu
discussions-to: https://github.com/filecoin-project/FIPs/issues/131
status: Draft
type: Core
created: 2021-07-27
spec-sections: 
  - miner actors
  - lotus mining

---

## Simple Summary

A protocol for updating any sector with new data without re-sealing.

## Abstract

The intuition is that the miner "xor"-s (techically field addition) the new data with some unpredictable randomness into the last layer of the Proof of Replication.

The miner generates one message which proves that sector was updated with new data.

## Change Motivation

Since 90+% of sectors in the Filecoin Network are CC sectors, having a protocol that allows for updating CC sectors to store real data without incurring in a full re-sealing would massively improve our network in terms of the amount of real data stored through it. 

1. It would allow **decoupling sealing latency from deal-making speed** - offering storage clients an improved experience for how quickly their data can land in on-chain deals
2. It would **unlock the 8EiB of storage already committed to the Filecoin network** to be quickly used for deals - enabling a 100PiB+ client to make deals for their entire dataset with a single miner like [f0127595](https://filfox.info/en/address/f0127595) which already has 120PiB of committed capacity.
3. It makes **utilizing existing committed capacity much cheaper for miners** (since they’ve already invested the sealing cost), increasing the chances they pay clients to add FIL+ data to these sectors.

What this FIP does not support (see Future Work section)

* Deal updates
* Moving deals across sectors

## Specification

### One-messages Update Protocol
1. **Miner accepts and publishes storage deals (using PublishStorageDeals)**
2. **Miner updates an existing replica with deals**:
	1. Generate `dataRand = H(Comm(D_1, D_2, ..., D_N))` where `Comm(D_1, D_2, ..., D_N)` computes CommD of the sector from CommDs of deals.
	2. Encode the deal data into existing replica using `newReplica[i] = Enc(replica[i], data[i], dataRand)` function:
      	- `newReplica` is the vector of `Fr` elements of the new replica
      	- `sectorKey` is the vector of `Fr` elements of the CC sector replica data
      	- `data` is the vector of `Fr` elements of the deals data ordered and padded as done in the sealing subroutine
	3. Compute CommR_new (`UpdatingSectorCID`) of the `newReplica` and set `seed = H(CommR_new)`.
3. **Miner produces a proof of sector update.**:
   1. Let `seed = H(CommR_new)`
   2. Let `dataRand = H(CommD_new)`
   3. Generate a SNARK that proves
      1. For challenge `i=0..SectorUpdateProveChallenges`,  `c = ChallengeGen(seed, i)`
         1. Encoding: the following we correcty computed: `newReplica[c] = Enc(sectorKey[c], data[c], dataRand)`
         2. Inclusion proofs:
            1. `newReplica[c]` is the opening of `UpdatingSectorCID` at position `c`
            2. `sectorKey[c]` is the opening of `CommRLast` from `SealedSectorCID` at position `c`
            3. `data[c]` is the opening of `UnsealedSectorCID` at position `c`
4. **Miner publishes `Miner.ProveReplicaUpdate(SectorID, UpdatingSectorCID, deals []DealID, proof)`**:
	1. Verify the proof of correct data update:
		1. Check that `SectorID` was originally CC sector, and fetch `OriginalSectorCID` or if that is null, `SealedSectorCID`.
		2. Check that `SectorID` has no deals active that are not mentioned in the `deals` param.
		3. Compute `UnsealedSectorCID` (CommD) and `dataRand = H(CommD)` from on-chain info about `deals`.
		4. Compute `seed = H(UpdatingSectorCID)`.
		5. Generate challenges from `seed`.
		6. Verify that `proof` is valid for using inputs: `dataRand`, `seed`, `UnsealedSectorCID`, `CommR_new`, `CommR_original` and challanges.
	2. If `SectorOriginalCID` is null, set it to `SealedSectorCID`.
	2. Update `SealedSectorCID` with `UpdatingSectorCID`
	3. TODO: Keep the last DeclareUpdate epoch to simplify future retrieval

### Retrieving updated data

1. From the `replica`:
   2. Regenerate `sectorKey` by re-sealing the sector
   3. For each `i`: `Dec(sectorKey[i], replica[i], dataRand)`

### Algorithms

### Encoding

The current encoding algorithm is the following:

`Enc(sectorKey[i], data[i], rand) = sectorKey[i] + data[i] * rand`

The Encoding function is cheap and allows for parallel encoding. 

### Decoding

`Dec(sectorKey[i], replica[i], dataRand) = (replica[i] - sectorKey[i]) * (dataRand<sup>-1</sup>)`

The modular inverse of `dataRand` is computed only once per whole operation.

## Design Rationale

### Parameters choice

* `SectorUpdateProveChallenges`: 2450 (TODO confirm number of challenges)

TODO

## Backwards Compatibility

All sectors can be upgraded.

### Breaking immutability of sectors and deals



## Test Cases

TODO

## Security Considerations

### Loosing epsilon-Replication guarantees

This changes changes the security property of Filecoin. Retrievability of the files and space-hardness are still guaranteed. TODO: expand on this.

## Incentive Considerations

TODO

## Product Considerations

TODO

## Implementation

- TODO: Initial Pledge should be updated in one of the new methods, we believe it should be PreCommit.
- TODO: How do we best represent deals in Declare update? Do we relist all the deals or we show a diff of deals?
- TODO: If we were to do 10x the snark (which shouldn’t be a big burden) we can remove the PreCommit step and fold it into ProveCommit - is this something that we should try doing?

## Future work

* DeclareDeals to support deal transfer: allow moving deals from sector to sector
* CapacityDeals: allow purchasing a capacity of the storage of a miner instead of the storage of a specific deal
* Update protocol that does not require to perform an operation on a full sector.
* DealUpdates: a license to terminate a deal in place for a new one (e.g. a user wants to update a portion of their files)

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
